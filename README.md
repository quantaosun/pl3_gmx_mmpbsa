# pl3_gmx_mmpbsa

## Halogen-contained small molecule needs special address

An example of the final result of such a calculation (per-residue decomposition of binding free energy)

![image](https://user-images.githubusercontent.com/75652473/230804988-ecd647c8-a10b-4140-9c63-fde93d2b6045.png)


[![Use on Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/quantaosun/pl3_gmx_mmpbsa/HEAD)

Recommened workflow.
1. Docking with pl3 as per https://github.com/quantaosun/pl3
2. MD input files generation with Charmm gui input generator (solution builder), with files generated by pl3
3. MD simulation with local gromacs or gmx inside this pl3_gmx_mmpbsa binder environment
```
modify REAMD for loop to only run the first 1, with step5.production.mdp nsteps extended 10 times of original value

```
mdp file after 10 time logner than default (nsteps has been modified with one more 0)

```
integrator              = md
dt                      = 0.002
nsteps                  = 5000000
nstxtcout               = 50000
nstvout                 = 50000
nstfout                 = 50000
nstcalcenergy           = 100
nstenergy               = 1000
nstlog                  = 1000
;
cutoff-scheme           = Verlet
nstlist                 = 20
vdwtype                 = Cut-off
vdw-modifier            = Force-switch
rvdw_switch             = 1.0
rvdw                    = 1.2
rlist                   = 1.2
rcoulomb                = 1.2
coulombtype             = PME
;
tcoupl                  = Nose-Hoover
tc_grps                 = SOLU SOLV
tau_t                   = 1.0 1.0
ref_t                   = 303.15 303.15
;
pcoupl                  = Parrinello-Rahman
pcoupltype              = isotropic
tau_p                   = 5.0
compressibility         = 4.5e-5
ref_p                   = 1.0
;
constraints             = h-bonds
constraint_algorithm    = LINCS
continuation            = yes
;
nstcomm                 = 100
comm_mode               = linear
comm_grps               = SOLU SOLV
;
```

4. MMPBSA calcultion of protein-ligand based on MD trajectories (and per-residue decomposition)
5. Visualisation and/or chart/imge making with gmx_MMPBSA_ana 



Elaboration on step 3, modify README to only run 1 nano second instead of 10, so the final trajectory only named as step5_1.xtc, and all mmpbsa calculation will be on the basis of step5_1


Elaboration on step 4. To know the index for protein and ligand, run

```
gmx make_ndx -f step5_1.gro -o index2.ndx

```



To run mmpbsa calculation with decompositon 

```
gmx_MMPBSA -O -i mmpbsa.in -cs step5_1.tpr -ci index2.ndx -cg 1 13 -ct step5_1.xtc -cp topol.top -o FINAL_RESULTS.dat -eo FINAL_RESULTS.csv

```
where mmpbsa.in is 

```
&general
sys_name="Prot-Lig-ST",
startframe=1,
endframe=12,
/
&gb
igb=5, saltcon=0.150,
/

&decomp
idecomp=2, dec_verbose=3,
print_res="within 4"
/
```
To determine how many frames in your trajectory file, use pymol 
```
load step5_1.gro
load step5_1.xtc
```
# In case the small molecules contains F Cl Br, it is necessary to delete the virtual site not supported by gmx_MMPBSA. 

```
gmx_MMPBSA -O -i mmpbsa.in -cs step5_1.tpr -ci index2.ndx -cg 1 17 -ct step5_1.xtc -cp topol.top -o FINAL_RESULTS.dat -eo FINAL_RESULTS.cs
```
See details from https://valdes-tresanco-ms.github.io/gmx_MMPBSA/dev/examples/Protein_ligand_LPH_atoms_CHARMMff/, note the modification of topol.top is extremely easy to go wrong, be careful.

1. Similar to above, generate a new index file
```
_GMXMMPBSA_COM_index.ndx     _GMXMMPBSA_dummyreceptor.inpcrd   _GMXMMPBSA_LIG.inpcrd            _GMXMMPBSA_REC.pdb                  step5_10.gro                     step5_1.log
(gmxMMPBSA2) qq@qq-ASUS-TUF-Gaming-A15-FA506QM-FA506QM:~/Desktop/3rd_review/20230409/gromacs/MMPBSA$ gmx make_ndx -f step5_1.tpr -o index2.ndx 
               :-) GROMACS - gmx make_ndx, 2022.4-conda_forge (-:

Executable:   /home/qq/anaconda3/envs/gmxMMPBSA2/bin.AVX2_256/gmx
Data prefix:  /home/qq/anaconda3/envs/gmxMMPBSA2
Working dir:  /home/qq/Desktop/3rd_review/20230409/gromacs/MMPBSA
Command line:
  gmx make_ndx -f step5_1.tpr -o index2.ndx


Reading structure file
Reading file step5_1.tpr, VERSION 2022.2 (single precision)
Reading file step5_1.tpr, VERSION 2022.2 (single precision)
Going to read 0 old index file(s)
Analysing residue names:
There are:   361    Protein residues
There are: 32371      Other residues
Analysing Protein...
Analysing residues not classified as Protein/DNA/RNA/Water and splitting into groups...

  0 System              : 102688 atoms
  1 Protein             :  5924 atoms
  2 Protein-H           :  2952 atoms
  3 C-alpha             :   361 atoms
  4 Backbone            :  1083 atoms
  5 MainChain           :  1443 atoms
  6 MainChain+Cb        :  1781 atoms
  7 MainChain+H         :  1788 atoms
  8 SideChain           :  4136 atoms
  9 SideChain-H         :  1509 atoms
 10 Prot-Masses         :  5924 atoms
 11 non-Protein         : 96764 atoms
 12 Other               : 96764 atoms
 13 UNL                 :    36 atoms
 14 POT                 :    91 atoms
 15 CLA                 :   100 atoms
 16 TIP3                : 96537 atoms

 nr : group      '!': not  'name' nr name   'splitch' nr    Enter: list groups
 'a': atom       '&': and  'del' nr         'splitres' nr   'l': list residues
 't': atom type  '|': or   'keep' nr        'splitat' nr    'h': help
 'r': residue              'res' nr         'chain' char
 "name": group             'case': case sensitive           'q': save and quit
 'ri': residue index

> splitat 13
```

# In case you have to use Bash instead of csh 
```
#!/bin/bash
#
# Generated by CHARMM-GUI (http://www.charmm-gui.org) v3.7
#
# This folder contains GROMACS formatted CHARMM36 force fields, a pre-optimized PDB structure, and GROMACS inputs.
# All input files were optimized for GROMACS 2019.2 or above, so lower version of GROMACS can cause some errors.
# We adopted the Verlet cut-off scheme for all minimization, equilibration, and production steps because it is 
# faster and more accurate than the group scheme. If you have a trouble with a performance of Verlet scheme while 
# running parallelized simulation, you should check if you are using appropriate command line.
# For MPI parallelizing, we recommand following command:
# mpirun -np $NUM_CPU gmx mdrun -ntomp 1

init="step3_input"
mini_prefix="step4.0_minimization"
equi_prefix="step4.1_equilibration"
prod_prefix="step5_production"
prod_step="step5"

# Minimization
# In the case that there is a problem during minimization using a single precision of GROMACS, please try to use 
# a double precision of GROMACS only for the minimization step.
#gmx grompp -f "${mini_prefix}.mdp" -o "${mini_prefix}.tpr" -c "${init}.gro" -r "${init}.gro" -p topol.top -n index.ndx -maxwarn -1
#gmx mdrun -v -deffnm "${mini_prefix}" -ntmpi 1


# Equilibration
#gmx grompp -f "${equi_prefix}.mdp" -o "${equi_prefix}.tpr" -c "${mini_prefix}.gro" -r "${init}.gro" -p topol.top -n index.ndx
#gmx mdrun -v -deffnm "${equi_prefix}" -ntmpi 1


# Production
cnt=1
cntmax=2

while [ $cnt -le $cntmax ]
do
    pcnt=$((cnt-1))
    istep="${prod_step}_${cnt}"
    pstep="${prod_step}_${pcnt}"

    if [ $cnt -eq 1 ]
    then
        pstep="${equi_prefix}"
        gmx grompp -f "${prod_prefix}.mdp" -o "${istep}.tpr" -c "${pstep}.gro" -p topol.top -n index.ndx
    else
        gmx grompp -f "${prod_prefix}.mdp" -o "${istep}.tpr" -c "${pstep}.gro" -t "${pstep}.cpt" -p topol.top -n index.ndx
    fi

    gmx mdrun -v -deffnm "${istep}" -ntmpi 1
    cnt=$((cnt+1))
done
```

